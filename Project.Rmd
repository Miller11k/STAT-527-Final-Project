---
title: "Project"
author: "Miller Kodish, Ian Ou, Vinay Pundith"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# install.packages("rstudioapi")
# Install only if missing — SAFE during knitting
if (!requireNamespace("here", quietly = TRUE)) {
  install.packages("here")
}
library(here)
library(ggplot2)
library(tidyverse)
library(tidymodels)
library(randomForest)
```

# Loading In Datasets

```{r}
# Geekbench datasets
recent_cpu <- read.csv(here("Datasets", "Geekbench", "recent-cpu-v6.csv"))
recent_gpu <- read.csv(here("Datasets", "Geekbench", "recent-gpu-v6.csv"))
single_core <- read.csv(here("Datasets", "Geekbench", "single-core-v4.csv"))
```


```{r}
top_multi <- read.csv(here("Datasets", "Geekbench", "top-multi-core-v6.csv"))
top_single <- read.csv(here("Datasets", "Geekbench", "top-single-core-v6.csv"))

# Kaggle datasets
gpu_benchmarks <- read.csv(here("Datasets", "Kaggle", "GPU_benchmarks_v7.csv"))
gpu_scores <- read.csv(here("Datasets", "Kaggle", "GPU_scores_graphicsAPIs.csv"))
```

## Verifying Datasets Loaded In Correctly
```{r}
# Print basic info for each dataset
datasets <- list(
  recent_cpu = recent_cpu,
  recent_gpu = recent_gpu,
  single_core = single_core,
  top_multi = top_multi,
  top_single = top_single,
  gpu_benchmarks = gpu_benchmarks,
  gpu_scores = gpu_scores
)

for (name in names(datasets)) {
  cat("===== Dataset:", name, "=====\n")
  cat("Rows:", nrow(datasets[[name]]), " | Columns:", ncol(datasets[[name]]), "\n\n")
  cat("Column Names:\n")
  print(names(datasets[[name]]))
  cat("\nStructure:\n")
  str(datasets[[name]], max.level = 1)
  cat("\n\n")
}
```
```{r}
gpu_benchmarks$gpu_name <- tolower(trimws(gpu_benchmarks$gpuName))
gpu_scores$gpu_name     <- tolower(trimws(gpu_scores$Device))

merged_gpu <- merge(
  gpu_benchmarks,
  gpu_scores,
  by = "gpu_name"
)

cat("Rows in PassMark dataset :", nrow(gpu_benchmarks), "\n")
cat("Rows in Geekbench dataset:", nrow(gpu_scores), "\n")
cat("Rows in merged dataset   :", nrow(merged_gpu), "\n\n")
merged_gpu$gpuName <- NULL
merged_gpu$Device <- NULL
head(merged_gpu)
```

# Filtering GPU Datasets By Manufacturer
```{r}
unique(gpu_scores$Manufacturer)
```


```{r}
manufacturers <- c("Nvidia", "AMD", "Apple", "Qualcomm", "Intel", 
                   "Other", "ARM", "PowerVR", "Samsung")

gpu_split <- split(gpu_scores, factor(gpu_scores$Manufacturer, levels = manufacturers))

for (m in manufacturers) {
  assign(
    paste0(tolower(m), "_gpu_scores"),   # variable name
    subset(gpu_scores, Manufacturer == m)   # filtered dataset
  )
}

# This creates:
#   nvidia_gpu_scores
#   amd_gpu_scores
#   apple_gpu_scores
#   qualcomm_gpu_scores
#   intel_gpu_scores
#   other_gpu_scores
#   arm_gpu_scores
#   powervr_gpu_scores
#   samsung_gpu_scores
```

```{r}
# Sort manufacturers alphabetically, but move "Other" to the end
sorted_manufacturers <- sort(manufacturers[manufacturers != "Other"])
sorted_manufacturers <- c(sorted_manufacturers, "Other")

# Print summary for each manufacturer dataset
for (m in sorted_manufacturers) {
  var_name <- paste0(tolower(m), "_gpu_scores")
  df <- get(var_name)
  
  cat("==== Dataset for:", m, "====\n")
  cat("Rows:", nrow(df), " | Columns:", ncol(df), "\n\n")
  
  cat("Column Names:\n")
  print(names(df))
  
  cat("\nHead (first 3 rows):\n")
  print(head(df, 3))
  
  cat("\n\n")
}
```

# Filtering GPU Dataset By Test Ran
```{r}
cuda_tests    <- subset(gpu_scores, !is.na(CUDA))
metal_tests   <- subset(gpu_scores, !is.na(Metal))
opencl_tests  <- subset(gpu_scores, !is.na(OpenCL))
vulkan_tests  <- subset(gpu_scores, !is.na(Vulkan))

test_types <- c("CUDA", "Metal", "OpenCL", "Vulkan")
test_datasets <- list(
  CUDA   = cuda_tests,
  Metal  = metal_tests,
  OpenCL = opencl_tests,
  Vulkan = vulkan_tests
)

for (t in test_types) {
  df <- test_datasets[[t]]
  
  cat("==== GPUs With", t, "Tests Ran ====\n")
  cat("Rows:", nrow(df), " | Columns:", ncol(df), "\n\n")
  
  cat("Column Names:\n")
  print(names(df))
  
  cat("\nHead (first 3 rows):\n")
  print(head(df, 3))
  
  cat("\n\n")
}
```

# Filtering by Manufacturer AND Test Ran
```{r}
# Manufacturer × Test combinations
tests <- c("CUDA", "Metal", "OpenCL", "Vulkan")

# Sort manufacturers alphabetically, but move "Other" to the end
sorted_manufacturers <- sort(manufacturers[manufacturers != "Other"])
sorted_manufacturers <- c(sorted_manufacturers, "Other")

for (m in sorted_manufacturers) {
  for (t in tests) {
    
    # Filter by manufacturer AND non-NA in test
    df <- subset(gpu_scores, Manufacturer == m & !is.na(gpu_scores[[t]]))
    
    # Skip empty datasets (DO NOT CREATE THE VARIABLE)
    if (nrow(df) == 0) {
      next
    }
    
    # Build variable name: manufacturer_test_gpu_scores
    var_name <- paste0(
      tolower(m), "_",
      tolower(t), "_gpu_scores"
    )
    
    # Save only if data exists
    assign(var_name, df)
    
    # Print summary
    cat("====", m, "-", t, "Test ====\n")
    cat("Rows:", nrow(df), " | Columns:", ncol(df), "\n\n")
    
    cat("Column Names:\n")
    print(names(df))
    
    cat("\nHead (first 3 rows):\n")
    print(head(df, 3))
    
    cat("\n\n")
  }
}
```

```{r}
ls(pattern = "_gpu_scores$")
```

Generate plot to see relationship between CUDA/OpenCL/Vulkan to G3dmark
```{r}
plot_scatter <- function(x_col, y_col, data) {
  ggplot(data, aes_string(x = x_col, y = y_col, color = "Manufacturer")) +
    geom_point(alpha = 0.7) +
    theme_minimal() +
    labs(
      title = paste(x_col, "vs", y_col),
      x = paste(x_col, "(PassMark)"),
      y = paste(y_col, "(Geekbench 5)"),
      color = "Manufacturer"
    )
}

# G3Dmark vs CUDA
print(plot_scatter("G3Dmark", "CUDA", merged_gpu))
# G3Dmark vs OpenCL
print(plot_scatter("G3Dmark", "OpenCL", merged_gpu))
# G3Dmark vs Vulkan
print(plot_scatter("G3Dmark", "Vulkan", merged_gpu))
# G3Dmark vs Metal (mostly Apple GPUs)
if ("Metal" %in% names(merged_gpu)) {
  print(plot_scatter("G3Dmark", "Metal", merged_gpu))
}
# Manufacturer Distribution
ggplot(merged_gpu, aes(x = Manufacturer)) +
  geom_bar() +
  theme_minimal() +
  labs(
    title = "GPU Manufacturer Count in Merged Dataset",
    x = "Manufacturer",
    y = "Count"
  )
```

Plot the trends 
```{r}
# gpu performance over time
ggplot(merged_gpu, aes(x = testDate, y = G3Dmark)) +
  geom_point(alpha = 0.4, color = "steelblue") +
  geom_smooth(method = "loess", se = FALSE, color = "darkblue") +
  theme_minimal() +
  labs(
    title = "GPU Performance Trend Over Time",
    x = "Year",
    y = "G3Dmark (PassMark Performance Score)"
  )

# tdp over time
ggplot(merged_gpu, aes(x = testDate, y = TDP)) +
  geom_point(alpha = 0.4, color = "firebrick") +
  geom_smooth(method = "loess", se = FALSE, color = "darkred") +
  theme_minimal() +
  labs(
    title = "GPU Power Consumption Trend Over Time",
    x = "Year",
    y = "TDP (Watts)"
  )

# performance per watt over time
merged_gpu$PerfPerWatt <- merged_gpu$G3Dmark / merged_gpu$TDP
ggplot(merged_gpu, aes(x = testDate, y = PerfPerWatt)) +
  geom_point(alpha = 0.4, color = "forestgreen") +
  geom_smooth(method = "loess", se = FALSE, color = "darkgreen") +
  theme_minimal() +
  labs(
    title = "GPU Efficiency Trend Over Time",
    x = "Year",
    y = "G3Dmark per Watt"
  )


# amd vs nvidia
ggplot(merged_gpu, aes(x = testDate, y = G3Dmark, color = Manufacturer)) +
  geom_point(alpha = 0.5) +
  geom_smooth(se = FALSE) +
  theme_minimal() +
  labs(
    title = "Performance Trend Over Time by Manufacturer",
    x = "Year",
    y = "G3Dmark Score"
  )
```

Build a simple linear regression model
```{r}
data <- merged_gpu |> select(G3Dmark, testDate, TDP, price, Manufacturer, category) |>drop_na()
lin_recipe <- recipe(G3Dmark ~ ., data = data) |> step_dummy(all_nominal_predictors())
lin_spec <- linear_reg() |> set_engine("lm")
lin_wf <- workflow() |> add_model(lin_spec) |> add_recipe(lin_recipe)
lin_fit <- lin_wf |> fit(data = data)
lin_preds <- predict(lin_fit, new_data = data) |> bind_cols(data |> select(G3Dmark))
lin_metrics <- lin_preds |> metrics(truth = G3Dmark, estimate = .pred)
lin_metrics
```

Build a random forest model with feature importance (using Tidymodels)
```{r}
data <- merged_gpu |> select(G3Dmark, testDate, TDP, price, Manufacturer, category) |> drop_na() |> 
  mutate(Manufacturer=as.factor(Manufacturer), category = as.factor(category))

# split train/test 80/20
data_split <- initial_split(data, prop=0.8)
train_rf <- training(data_split)
test_rf  <- testing(data_split)

# make recipe
rf_recipe <- recipe(G3Dmark ~ testDate + TDP + price + Manufacturer + category, data=train_rf) |> step_normalize(all_numeric_predictors())

# make random forest model
rf_spec <-rand_forest(mtry=3, trees=500, min_n=5) |> set_mode("regression") |> set_engine("randomForest", importance = TRUE)

# user workflow and fit and predict
rf_wf <- workflow() |> add_model(rf_spec) |> add_recipe(rf_recipe)
rf_fit <- rf_wf |> fit(data = train_rf)
rf_preds <- predict(rf_fit, new_data=test_rf) |> bind_cols(test_rf |> select(G3Dmark))

# see metrics
rf_metrics <- rf_preds |> metrics(truth = G3Dmark, estimate = .pred)
rf_metrics

rf_fit |> extract_fit_parsnip() |> pluck("fit") |> varImpPlot()
```

LASSO/Ridge Regression
```{r}
data <- merged_gpu |> select(G3Dmark, testDate, TDP, price, Manufacturer, category) |> drop_na() |> mutate(Manufacturer = factor(Manufacturer), category = factor(category))
set.seed(123)
reg_split <- initial_split(data, prop = 0.8)
train_reg <- training(reg_split)
test_reg  <- testing(reg_split)

reg_recipe <-
  recipe(G3Dmark ~ testDate + TDP + price + Manufacturer + category, data = train_reg) |> step_normalize(all_numeric_predictors()) |> step_dummy(all_nominal_predictors())


ridge_spec <-linear_reg(penalty = tune(), mixture = 0) |> set_engine("glmnet")
lasso_spec <-linear_reg(penalty = tune(),mixture = 1) |> set_engine("glmnet")
ridge_wf <- workflow() |> add_model(ridge_spec) |> add_recipe(reg_recipe)
lasso_wf <- workflow() |> add_model(lasso_spec) |> add_recipe(reg_recipe)

set.seed(123)
reg_folds <- vfold_cv(train_reg, v = 5)
lambda_grid <- grid_regular(penalty(), levels = 30)
ridge_tuned <- tune_grid(ridge_wf, resamples = reg_folds, grid = lambda_grid, metrics = metric_set(rmse, rsq, mae))
lasso_tuned <-tune_grid(lasso_wf,resamples = reg_folds, grid = lambda_grid, metrics= metric_set(rmse, rsq, mae))

best_ridge <- ridge_tuned |> select_best(metric = "rmse")
best_lasso <- lasso_tuned |> select_best(metric = "rmse")
best_ridge
best_lasso

ridge_final_fit <-ridge_wf |> finalize_workflow(best_ridge) |> fit(data = train_reg)
lasso_final_fit <- lasso_wf |> finalize_workflow(best_lasso) |> fit(data = train_reg)

ridge_preds <-predict(ridge_final_fit, new_data = test_reg) |> bind_cols(test_reg |> select(G3Dmark))
lasso_preds <-predict(lasso_final_fit, new_data = test_reg) |> bind_cols(test_reg |> select(G3Dmark))

ridge_metrics <- ridge_preds |> metrics(truth = G3Dmark, estimate = .pred)
lasso_metrics <- lasso_preds |> metrics(truth = G3Dmark, estimate = .pred)
ridge_metrics
lasso_metrics
```